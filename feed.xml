<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learn â†’ Swift Feed</title>
  <subtitle>A no-frills introduction to Swift</subtitle>
  <id>http://learn-swift.co</id>
  <link href="http://learn-swift.co"/>
  <link href="http://learn-swift.co/feed" rel="self"/>
  <updated>2014-08-06T20:55:00+02:00</updated>
  <author>
    <name>Reda Lemeden</name>
  </author>
  <entry>
    <title>Optionals</title>
    <link rel="alternate" href="http://learn-swift.co/optionals/"/>
    <id>http://learn-swift.co/optionals/</id>
    <published>2014-08-06T20:55:00+02:00</published>
    <updated>2014-08-12T00:31:50+02:00</updated>
    <author>
      <name>Reda Lemeden</name>
    </author>
    <content type="html">&lt;h3 id="declaring-optionals"&gt;Declaring Optionals&lt;/h3&gt;

&lt;p&gt;Optionals are variables or constants that can either have a value or be &lt;code&gt;nil&lt;/code&gt;.
They are defined by appending a &lt;code&gt;?&lt;/code&gt; at the end of the type in the declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var dropItemName: String? // Enemy may or may not drop item
dropItemName = &amp;quot;Wizard&amp;#39;s Relic&amp;quot;
dropItemName = nil // This would have raised an error if the variable wasn&amp;#39;t an optional
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="inspecting-optionals"&gt;Inspecting Optionals&lt;/h3&gt;

&lt;p&gt;You can compare the optional against &lt;code&gt;nil&lt;/code&gt; to find out if it contains a value or
not:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;dropItemName == nil // &amp;lt;- true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can also be used in &lt;code&gt;if&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;if dropItemName == nil {
  println(&amp;quot;Out of luck.&amp;quot;) // &amp;lt;-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="forced-unwrapping"&gt;Forced Unwrapping&lt;/h3&gt;

&lt;p&gt;If the optional is guaranteed to contain a value, you can &lt;em&gt;unwrap&lt;/em&gt; its value using an
exclamation mark at the end of the optional name:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;dropItemName = &amp;quot;Elixir&amp;quot;
if dropItemName != nil {
  println(&amp;quot;You got an unwrapped \(dropItemName!)&amp;quot;) // &amp;lt;-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unwrapping allows you to directly access the value contained in the optional.&lt;/p&gt;

&lt;h3 id="optional-binding"&gt;Optional Binding&lt;/h3&gt;

&lt;p&gt;You can also bind a variable or a constant to the value contained in an
optional in an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;if let itemName = dropItemName {
  println(&amp;quot;This is undoubtedly an \(itemName)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="implicit-unwrapping"&gt;Implicit Unwrapping&lt;/h3&gt;

&lt;p&gt;If an optional is guaranteed to &lt;em&gt;always&lt;/em&gt; contain a value, it can be declared as an
&lt;em&gt;implicitly unwrapped optional&lt;/em&gt; by appending an exclamation mark to its type in
the definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var implicitlyUnwrappedItemName: String! = &amp;quot;Omega Arts&amp;quot;
println(&amp;quot;\(implicitlyUnwrappedItemName) is a certain drop.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this method, you don&amp;rsquo;t have to append &lt;code&gt;!&lt;/code&gt; to unwrap the value contained in
the optional; it will be implicitly unwrapped for you.&lt;/p&gt;

&lt;h3 id="optional-chaining"&gt;Optional Chaining&lt;/h3&gt;

&lt;p&gt;You can use &lt;em&gt;optional chaining&lt;/em&gt; to call a method on an optional. In order to do
so, append a question mark to the name of the optional, just before the dot
preceding the method name:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let dropRates: [String: Float]? = [&amp;quot;Wizard&amp;#39;s Relic&amp;quot;: 0.002, &amp;quot;Shiny Crystal&amp;quot;: 0.2, &amp;quot;Ether&amp;quot;: 0.2]
dropRates.isEmpty // -&amp;gt; Error
dropRates?.isEmpty // -&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Optional chaining can also be used to get/set properties, which will be
introduced later.&lt;/p&gt;

&lt;h3 id="nil-coalescing-operator"&gt;Nil Coalescing Operator&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;nil coalescing operator&lt;/em&gt; &lt;code&gt;??&lt;/code&gt; is used to unwrap an optional if it&amp;rsquo;s not
&lt;code&gt;nil&lt;/code&gt; or return a default value otherwise:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let weaponOfChoice: String? = &amp;quot;One Winged Angel&amp;quot;
let currentWeapon = weaponOfChoice ?? &amp;quot;Kingdom Key&amp;quot;
currentWeapon // -&amp;gt; &amp;quot;One Winged Angel&amp;quot;

let shieldOfChoice: String? = nil
let currentShield = shieldOfChoice ?? &amp;quot;Knight&amp;#39;s Shield&amp;quot;
currentShield // -&amp;gt; &amp;quot;Knight&amp;#39;s Shield&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
    <summary>Optionals are variables or constants that can either have a value or be nil.</summary>
  </entry>
  <entry>
    <title>Basic Control Flow</title>
    <link rel="alternate" href="http://learn-swift.co/basic-control-flow/"/>
    <id>http://learn-swift.co/basic-control-flow/</id>
    <published>2014-08-06T17:00:00+02:00</published>
    <updated>2014-08-11T20:57:50+02:00</updated>
    <author>
      <name>Reda Lemeden</name>
    </author>
    <content type="html">&lt;h3 id="conditional-statements"&gt;Conditional Statements&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;if&lt;/code&gt; statement evaluates a boolean value and executes a code block if it&amp;rsquo;s
&lt;code&gt;true&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let elementalType = &amp;quot;Fire&amp;quot;

if elementalType == &amp;quot;Fire&amp;quot; {
  println(&amp;quot;Use water!&amp;quot;) // &amp;lt;-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;else&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;if elementalType == &amp;quot;Fairy&amp;quot; {
  println(&amp;quot;Use poison!&amp;quot;)
} else {
  println(&amp;quot;Draco Meteor!&amp;quot;) // &amp;lt;-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="chaining-conditionals"&gt;Chaining Conditionals&lt;/h3&gt;

&lt;p&gt;Multiple &lt;code&gt;if&lt;/code&gt; statements can be chained:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;if elementalType == &amp;quot;Fairy&amp;quot; {
  println(&amp;quot;Use poison!&amp;quot;)
} else if elementalType == &amp;quot;Bug&amp;quot; {
  println(&amp;quot;Kill it with fire!&amp;quot;)
} else {
  println(&amp;quot;Draco Meteor Again.&amp;quot;) // &amp;lt;-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="switch-statements"&gt;Switch Statements&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;switch&lt;/code&gt; statement evaluates a value against multiple patterns
then executes the code corresponding to the one that matches:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;switch elementalType {
case &amp;quot;Fairy&amp;quot;:
  println(&amp;quot;Use poison!&amp;quot;)
case &amp;quot;Bug&amp;quot;:
  println(&amp;quot;Kill it with fire!&amp;quot;)
default:
  println(&amp;quot;More Draco Meteor.&amp;quot;) // &amp;lt;-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;switch&lt;/code&gt; statement needs to be exhaustive; every possible value should be
covered. The &lt;code&gt;default&lt;/code&gt; case covers all the remaining cases.&lt;/p&gt;

&lt;p&gt;A single case can check against multiple values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;switch elementalType {
case &amp;quot;Dragon&amp;quot;, &amp;quot;Flying&amp;quot;, &amp;quot;Grass&amp;quot;, &amp;quot;Ground&amp;quot;:
  println(&amp;quot;Freeze it to death.&amp;quot;)
case &amp;quot;Ice&amp;quot;:
  println(&amp;quot;Melt it with fire!&amp;quot;)
default:
  println(&amp;quot;Ready for another Draco Meteor?&amp;quot;) // &amp;lt;-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="switch-fall-through"&gt;Switch Fall-through&lt;/h3&gt;

&lt;p&gt;The execution of a &lt;code&gt;switch&lt;/code&gt; statement stops as soon a case is matched:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let fireType = &amp;quot;Fire&amp;quot;

switch fireType {
case &amp;quot;Fire&amp;quot;:
  println(&amp;quot;Go, Squirtle!&amp;quot;) // &amp;lt;-
default:
  println(&amp;quot;Your turn will never come, Pikachu...&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also explicitly end execution using the keyword &lt;code&gt;break&lt;/code&gt; anywhere in the
statement.&lt;/p&gt;

&lt;h3 id="range-matching"&gt;Range Matching&lt;/h3&gt;

&lt;p&gt;Cases in a &lt;code&gt;switch&lt;/code&gt; statement can check if a value is included in a range:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let baseAttack = 89

switch baseAttack {
case 1...30:
  println(&amp;quot;Jus release it.&amp;quot;)
case 31...70:
  println(&amp;quot;Meh&amp;quot;)
case 71...150:
  println(&amp;quot;Now we&amp;#39;re talking!&amp;quot;) // &amp;lt;-
case 151...200:
  println(&amp;quot;Uber!&amp;quot;)
default:
  println(&amp;quot;Hackemon!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="tuple-matching"&gt;Tuple Matching&lt;/h3&gt;

&lt;p&gt;Tuples can be used as values in &lt;code&gt;switch&lt;/code&gt; cases. You can ignore a value in the
tuple by replacing it with &lt;code&gt;_&lt;/code&gt; in the case&amp;rsquo;s test:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let baseSpecialAttack = 55
let baseMixedAttack = (baseAttack, baseSpecialAttack)

switch baseMixedAttack {
case (80...200, 80...200):
  println(&amp;quot;Good mixed sweeper.&amp;quot;)
case (_, 80...200):
  println(&amp;quot;Good special sweeper.&amp;quot;)
case (80...200, _):
  println(&amp;quot;Good physical sweeper.&amp;quot;) // &amp;lt;-
default:
  println(&amp;quot;Not competitive enough.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="binding-values"&gt;Binding Values&lt;/h3&gt;

&lt;p&gt;Matched values can be bound to constants or variables and reused
inside the case&amp;rsquo;s body:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;switch baseMixedAttack {
case (80...200, let specialAttack):
  println(&amp;quot;Good physical sweeper with a special attack of \(specialAttack)&amp;quot;) // &amp;lt;-
case (let attack, 80...200):
  println(&amp;quot;Good special sweeper with an attack of \(attack)&amp;quot;)
default:
  println(&amp;quot;Not competitive enough.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="where"&gt;Where&lt;/h3&gt;

&lt;p&gt;Cases in a &lt;code&gt;switch&lt;/code&gt; statement can use a &lt;code&gt;where&lt;/code&gt; clause to perform additional checks:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;switch baseMixedAttack {
case let (attack, specialAttack) where attack == specialAttack:
  println(&amp;quot;Perfectly balanced attack stats.&amp;quot;)
default:
  println(&amp;quot;Unbalanced attack stats.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</content>
    <summary>This section takes a look at what Swift has to offer in terms of control flow, an essential part of every programming language. In this first part we will look at 'if' and 'switch' statements.</summary>
  </entry>
  <entry>
    <title>Basic Operators</title>
    <link rel="alternate" href="http://learn-swift.co/basic-operators/"/>
    <id>http://learn-swift.co/basic-operators/</id>
    <published>2014-07-30T17:45:00+02:00</published>
    <updated>2014-08-06T21:18:16+02:00</updated>
    <author>
      <name>Reda Lemeden</name>
    </author>
    <content type="html">&lt;h3 id="assignment-operator"&gt;Assignment Operator&lt;/h3&gt;

&lt;p&gt;The assignment operator (&lt;code&gt;=&lt;/code&gt;) is used either to initialize a value regardless of its type, or update it if it was declared as a variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let pokemonName = &amp;quot;Pikachu&amp;quot;
let mirrorPokemonName = pokemonName
mirrorPokemonName // -&amp;gt; &amp;quot;Pikachu&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The assignment operator does not return a value.&lt;/p&gt;

&lt;h3 id="arithmetic-operators"&gt;Arithmetic Operators&lt;/h3&gt;

&lt;p&gt;Swift comes with all the arithmetic operators you would expect in a modern
programming language.&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;35 + 10 // -&amp;gt; 45
35 - 10 // -&amp;gt; 25
10 * 2 // -&amp;gt; 20
10 / 3 // -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The addition operator can also be used to concatenate two or more strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;&amp;quot;Lightning&amp;quot; + &amp;quot; &amp;quot; + &amp;quot;Rod&amp;quot; // -&amp;gt; &amp;quot;Lightning Rod&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let moves = [&amp;quot;Tail Whip&amp;quot;, &amp;quot;Thunder Shock&amp;quot;]
let moreMoves = [&amp;quot;Growl&amp;quot;, &amp;quot;Play Nice&amp;quot;]
var moveSet = moves + moreMoves
moveSet // -&amp;gt; [&amp;quot;Tail Whip&amp;quot;, &amp;quot;Thunder Shock&amp;quot;, &amp;quot;Growl&amp;quot;, &amp;quot;Play Nice&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="range-operators"&gt;Range Operators&lt;/h3&gt;

&lt;p&gt;Range operators allow you to express a range of a values using lower and upper
bounds. They come in two flavors.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;closed range operator&lt;/em&gt; includes the value corresponding to the upper bound:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;moveSet[1...2] // -&amp;gt; [&amp;quot;Thunder Shock&amp;quot;, &amp;quot;Growl&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;half-closed&lt;/em&gt; range operator omits the value corresponding to the upper
bound:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;moveSet[1..&amp;lt;2] // -&amp;gt; [&amp;quot;Thunder Shock&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="remainder-operator"&gt;Remainder Operator&lt;/h3&gt;

&lt;p&gt;The remainder operator (&lt;code&gt;%&lt;/code&gt;) outputs the remainder of a division of two numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;10 % 3 // -&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It also works with floats and negative numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;35 % -15 // -&amp;gt; 5
10 % 3.5 // -&amp;gt; 3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="compound-assignment-operators"&gt;Compound Assignment Operators&lt;/h3&gt;

&lt;p&gt;These operators execute an operation and assign the result to
the left operand at the same time:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var remainingHP = 35
remainingHP += 10 // -&amp;gt; 45 (remainingHP = remainingHP + 10)
remainingHP -= 10 // -&amp;gt; 35 (remainingHP = remainingHP - 10)
remainingHP *= 2 // -&amp;gt; 70 (remainingHP = remainingHP * 2)
remainingHP /= 2 // -&amp;gt; 35 (remainingHP = remainingHP / 2)
remainingHP %= 6 // -&amp;gt; 5 (remainingHP = remainingHP % 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="unary-operators"&gt;Unary Operators&lt;/h3&gt;

&lt;p&gt;Swift has all the unary operators that are common in other languages:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;remainingHP = 35
++remainingHP // -&amp;gt; 36
--remainingHP // -&amp;gt; 35

let damageToKO = -remainingHP // -&amp;gt; -35
+damageToKO // -&amp;gt; -35
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the unary &lt;em&gt;plus&lt;/em&gt; operator is just syntactic sugar and does not change
the value it was prepended to.&lt;/p&gt;

&lt;p&gt;If the increment or decrement operators are appended as postfix operators
(&lt;code&gt;value++&lt;/code&gt;), the variable is modified &lt;em&gt;after&lt;/em&gt; its value is returned:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;remainingHP // -&amp;gt; 35
remainingHP-- // -&amp;gt; 35
remainingHP // -&amp;gt; 34
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="comparison-operators"&gt;Comparison Operators&lt;/h3&gt;

&lt;p&gt;Comparison operators are binary operators that compare two values and return a
boolean:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;35 == 35 // -&amp;gt; true (is equal)
180 != 35 // -&amp;gt; true (is not equal)

180 &amp;gt; 35 // -&amp;gt; true (is greater than)
35 &amp;lt; 180 // -&amp;gt; true (is less than)

35 &amp;gt;= 35 // -&amp;gt; true (is greater than or equal)
180 &amp;lt;= 35 // -&amp;gt; false (is less than or equal)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="logical-operators"&gt;Logical Operators&lt;/h3&gt;

&lt;p&gt;Swift has three logical operators that all return a boolean value:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The NOT operator (&lt;code&gt;!value&lt;/code&gt;) inverts a boolean value.&lt;/li&gt;
&lt;li&gt;The AND operator (&lt;code&gt;value1 &amp;amp;&amp;amp; value2&lt;/code&gt;) returns &lt;code&gt;true&lt;/code&gt; if all values are
&lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The OR operator (&lt;code&gt;value1 || value2&lt;/code&gt;) returns &lt;code&gt;true&lt;/code&gt; if at least one value is
&lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var damage = 56
var lastPokemon = true
var oneHitKO = (damage &amp;gt; remainingHP) // -&amp;gt; true

!oneHitKO // -&amp;gt; false
!oneHitKO &amp;amp;&amp;amp; lastPokemon // -&amp;gt; false
!oneHitKO || lastPokemon // -&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
</content>
    <summary>Operators are symbols that are used to modify or inspect values. Let's backtrack a bit and have a look at some basic ones in Swift.</summary>
  </entry>
  <entry>
    <title>Tuples</title>
    <link rel="alternate" href="http://learn-swift.co/tuples/"/>
    <id>http://learn-swift.co/tuples/</id>
    <published>2014-07-28T14:30:00+02:00</published>
    <updated>2014-07-30T17:40:09+02:00</updated>
    <author>
      <name>Reda Lemeden</name>
    </author>
    <content type="html">&lt;h3 id="declaring-tuples"&gt;Declaring Tuples&lt;/h3&gt;

&lt;p&gt;Tuples group multiple values of possibly different types. They are declared using
parentheses:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let alertMode = (4, &amp;quot;Red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To explicitly set the type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let evasionMode: (Int, String) = (3, &amp;quot;Orange&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also name the values for easier access:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let cautionMode = (level: 2, color: &amp;quot;Lime&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="getting-tuple-values"&gt;Getting Tuple Values&lt;/h3&gt;

&lt;p&gt;Use dot syntax to access the value stored at a given index:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let alertColor = alertMode.1 // -&amp;gt; &amp;quot;Red&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use the following syntax to retrieve some values while ignoring others:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let (_, evasionColor) = evasionMode
evasionColor // -&amp;gt; &amp;quot;Orange&amp;quot;
let (evasionLevel, _) = evasionMode
evasionLevel // -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the values were named during declaration, you can access them using
their names:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let cautionColor = cautionMode.color // -&amp;gt; &amp;quot;Lime&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="updating-tuple-values"&gt;Updating Tuple Values&lt;/h3&gt;

&lt;p&gt;Declare tuples as variables in order to be able to update their values, then use
dot syntax (with indices or names) to do so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var normalMode = (1, &amp;quot;Blue&amp;quot;)
normalMode.1 = &amp;quot;Green&amp;quot;
normalMode // -&amp;gt; (1, &amp;quot;Green&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</content>
    <summary>Tuples are a type that groups multiple values of possibly different types.</summary>
  </entry>
  <entry>
    <title>Dictionaries</title>
    <link rel="alternate" href="http://learn-swift.co/dictionaries/"/>
    <id>http://learn-swift.co/dictionaries/</id>
    <published>2014-07-20T00:00:00+02:00</published>
    <updated>2014-08-06T21:18:16+02:00</updated>
    <author>
      <name>Reda Lemeden</name>
    </author>
    <content type="html">&lt;h3 id="declaring-dictionaries"&gt;Declaring Dictionaries&lt;/h3&gt;

&lt;p&gt;Dictionaries hold a collection of key and value pairs. Like arrays, they can be
declared using the bracket shorthand syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var bossNames = [&amp;quot;Emerald Hill&amp;quot;: &amp;quot;Mecha&amp;quot;, &amp;quot;Chemical Plant&amp;quot;: &amp;quot;Water&amp;quot;, &amp;quot;Aquatic Ruin&amp;quot;: &amp;quot;Hammer&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To explicitly set the type of a dictionary, you can use the &lt;code&gt;[Type: Type]&lt;/code&gt;
syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var moreBossNames: [String: String] = [:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All keys must be of the same type. The same applies for values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var bossNames: [String: String] = [&amp;quot;Emerald Hill&amp;quot;: &amp;quot;Drill&amp;quot;, 2: &amp;quot;Water&amp;quot;] // -&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="inspecting-dictionaries"&gt;Inspecting Dictionaries&lt;/h3&gt;

&lt;p&gt;You can get the number of key/value pairs in a dictionary using &lt;code&gt;count&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;bossNames.count // -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check whether a dictionary is empty, you can use the &lt;code&gt;isEmpty()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;bossNames.isEmpty // -&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="getting-dictionary-values"&gt;Getting Dictionary Values&lt;/h3&gt;

&lt;p&gt;Like arrays, you can use subscript syntax to retrieve the value&lt;sup id="fnref1"&gt;&lt;a href="#fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; corresponding to
a given key.&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;bossNames[&amp;quot;Chemical Plant&amp;quot;] // -&amp;gt; &amp;quot;Water&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="adding-to-a-dictionary"&gt;Adding to a Dictionary&lt;/h3&gt;

&lt;p&gt;To add a new key/value pair, use the subscript operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;moreBossNames[&amp;quot;Casino Night&amp;quot;] = &amp;quot;Catcher&amp;quot;
moreBossNames // -&amp;gt; [&amp;quot;Casino Night&amp;quot;: &amp;quot;Catcher&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="updating-dictionary-values"&gt;Updating Dictionary Values&lt;/h3&gt;

&lt;p&gt;To update an existing value, use the subscript syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;bossNames[&amp;quot;Emerald Hill&amp;quot;] = &amp;quot;Drill&amp;quot;
bossNames // -&amp;gt; [&amp;quot;Emerald Hill&amp;quot;: &amp;quot;Drill&amp;quot;, &amp;quot;Aquatic Ruin&amp;quot;: &amp;quot;Hammer&amp;quot;, &amp;quot;Chemical Plant&amp;quot;: &amp;quot;Water&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="mutating-dictionaries"&gt;Mutating Dictionaries&lt;/h3&gt;

&lt;p&gt;Mutating the values included in a dictionary requires the latter
to be declared as a variable using the &lt;code&gt;var&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let constantBossNames: [String: String] = [:]
constantBossNames[&amp;quot;Emerald Hill&amp;quot;] = &amp;quot;Drill&amp;quot; // -&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="deleting-dictionary-values"&gt;Deleting Dictionary Values&lt;/h3&gt;

&lt;p&gt;To delete an existing key/value pair, make its value &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;bossNames[&amp;quot;Chemical Plant&amp;quot;] = nil
bossNames // -&amp;gt; [&amp;quot;Emerald Hill&amp;quot;: &amp;quot;Drill&amp;quot;, &amp;quot;Aquatic Ruin&amp;quot;: &amp;quot;Hammer&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;div class="footnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;

&lt;li id="fn1"&gt;
&lt;p&gt;In practice, what you get is an optional value, which means it can be &lt;code&gt;nil&lt;/code&gt;. More on that later.&amp;nbsp;&lt;a href="#fnref1" rev="footnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;
</content>
    <summary>In this section, we'll take a look at Swift dictionaries.</summary>
  </entry>
  <entry>
    <title>Arrays</title>
    <link rel="alternate" href="http://learn-swift.co/arrays/"/>
    <id>http://learn-swift.co/arrays/</id>
    <published>2014-07-05T00:00:00+02:00</published>
    <updated>2014-08-06T21:18:16+02:00</updated>
    <author>
      <name>Reda Lemeden</name>
    </author>
    <content type="html">&lt;h3 id="declaring-arrays"&gt;Declaring Arrays&lt;/h3&gt;

&lt;p&gt;Arrays hold a collection of values with the same type. They
can be declared using the bracket shorthand syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var levelNames = [&amp;quot;Green Hill&amp;quot;, &amp;quot;Marble&amp;quot;, &amp;quot;Spring Yard&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type of values in an array can be inferred as in the example above (string).
It can also be explicitly set using the &lt;code&gt;[Type]&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var moreLevelNames: [String] = []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An array can only hold values of the same type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var levelNames: [String] = [&amp;quot;Green Hill&amp;quot;, 2, &amp;quot;Labyrinth&amp;quot;] // -&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="inspecting-arrays"&gt;Inspecting Arrays&lt;/h3&gt;

&lt;p&gt;You can get the number of values in an array using &lt;code&gt;count&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames.count // -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check whether an array is empty, you can use the &lt;code&gt;isEmpty()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames.isEmpty // -&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the first or last value&lt;sup id="fnref1"&gt;&lt;a href="#fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; in an array, use the &lt;code&gt;first()&lt;/code&gt; and &lt;code&gt;last()&lt;/code&gt; methods respectively:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames.first // -&amp;gt; &amp;quot;Green Hill&amp;quot;
levelNames.last // -&amp;gt; &amp;quot;Spring Yard&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="getting-array-values"&gt;Getting Array Values&lt;/h3&gt;

&lt;p&gt;Use subscript syntax to access the value stored at a given index:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames[0] // -&amp;gt; &amp;quot;Green Hill&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the first item has an index of 0.&lt;/p&gt;

&lt;h3 id="adding-array-values"&gt;Adding Array Values&lt;/h3&gt;

&lt;p&gt;To add a new value, use the &lt;code&gt;append()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;moreLevelNames.append(&amp;quot;Star Light&amp;quot;)
moreLevelNames // -&amp;gt; [&amp;quot;Star Light&amp;quot;]
moreLevelNames.append(&amp;quot;Final&amp;quot;)
moreLevelNames // -&amp;gt; [&amp;quot;Star Light&amp;quot;, &amp;quot;Final&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="concatenating-arrays"&gt;Concatenating Arrays&lt;/h3&gt;

&lt;p&gt;You can concatenate two arrays using the &lt;code&gt;+=&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames += moreLevelNames
// -&amp;gt; [&amp;quot;Green Hill&amp;quot;, &amp;quot;Marble&amp;quot;, &amp;quot;Spring Yard&amp;quot;, &amp;quot;Star Light&amp;quot;, &amp;quot;Final&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="mutating-arrays"&gt;Mutating Arrays&lt;/h3&gt;

&lt;p&gt;In order to mutate the values included in an array, it needs to be declared as a variable using the
keyword &lt;code&gt;var&lt;/code&gt;; constant arrays are immutable:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let constantLevelNames: [String] = []
constantLevelNames.append(&amp;quot;Final&amp;quot;) // -&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="inserting-values"&gt;Inserting Values&lt;/h3&gt;

&lt;p&gt;To insert a value at a given index, use &lt;code&gt;insert&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames.insert(&amp;quot;Labyrinth&amp;quot;, atIndex: 3)
levelNames // -&amp;gt; [&amp;quot;Green Hill&amp;quot;, &amp;quot;Marble&amp;quot;, &amp;quot;Spring Yard&amp;quot;, &amp;quot;Labyrinth&amp;quot;, &amp;quot;Star Light&amp;quot;, &amp;quot;Final&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="updating-array-values"&gt;Updating Array Values&lt;/h3&gt;

&lt;p&gt;To update an existing value, use the subscript syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames[5] = &amp;quot;Scrap Brain&amp;quot;
levelNames // -&amp;gt; [&amp;quot;Green Hill&amp;quot;, &amp;quot;Marble&amp;quot;, &amp;quot;Spring Yard&amp;quot;, &amp;quot;Labyrinth&amp;quot;, &amp;quot;Star Light&amp;quot;, &amp;quot;Scrap Brain&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="deleting-array-values"&gt;Deleting Array Values&lt;/h3&gt;

&lt;p&gt;To delete a value, use &lt;code&gt;removeAtIndex()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;levelNames.removeAtIndex(5)
levelNames // -&amp;gt; [&amp;quot;Green Hill&amp;quot;, &amp;quot;Marble&amp;quot;, &amp;quot;Spring Yard&amp;quot;, &amp;quot;Labyrinth&amp;quot;, &amp;quot;Star Light&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;, for example when the array is empty. More on optionals later.&lt;/p&gt;

&lt;div class="footnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;

&lt;li id="fn1"&gt;
&lt;p&gt;In practice, what you get is an optional value, which means it can be&amp;nbsp;&lt;a href="#fnref1" rev="footnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;
</content>
    <summary>In this section, we'll take a look at Swift arrays.</summary>
  </entry>
  <entry>
    <title>Getting Started</title>
    <link rel="alternate" href="http://learn-swift.co/getting-started/"/>
    <id>http://learn-swift.co/getting-started/</id>
    <published>2014-06-13T00:00:00+02:00</published>
    <updated>2014-07-25T19:19:00+02:00</updated>
    <author>
      <name>Reda Lemeden</name>
    </author>
    <content type="html">&lt;h3 id="console-output"&gt;Console Output&lt;/h3&gt;

&lt;pre&gt;&lt;code class="swift"&gt;println(&amp;quot;Hello, Swift.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="variables"&gt;Variables&lt;/h3&gt;

&lt;p&gt;Variables are declared using the keyword &lt;code&gt;var&lt;/code&gt;, followed by the variable name
and its type (optional, see &lt;a href="#type-inference"&gt;Type Inference&lt;/a&gt;). A value can be assigned to the variable
using the &lt;code&gt;=&lt;/code&gt; operand:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var playerName: String = &amp;quot;Player 1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variables can be re-assigned:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;playerName = &amp;quot;Kaishin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variables cannot be &lt;code&gt;nil&lt;/code&gt;&lt;sup id="fnref1"&gt;&lt;a href="#fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;playerName = nil // -&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="constants"&gt;Constants&lt;/h3&gt;

&lt;p&gt;Constants are declared similarly to &lt;a href="#variables"&gt;variables&lt;/a&gt;, except they use the
keyword &lt;code&gt;let&lt;/code&gt; instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;let gameTitle: String = &amp;quot;Flappy Swift&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constants cannot be re-assigned:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;gameTitle = &amp;quot;Swift Valley&amp;quot; // -&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like variables, constants cannot be &lt;code&gt;nil&lt;/code&gt;&lt;sup id="fnref1"&gt;&lt;a href="#fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id="type-inference"&gt;Type Inference&lt;/h3&gt;

&lt;p&gt;Type inference refers to the compiler&amp;rsquo;s ability
to implicitly determine the type of a variable without having to
specify it in the declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var opponentName = &amp;quot;Player 2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="string-interpolation"&gt;String Interpolation&lt;/h3&gt;

&lt;p&gt;Values can be included in strings using a &lt;code&gt;\&lt;/code&gt; and the desired value between
parentheses:&lt;/p&gt;

&lt;pre&gt;&lt;code class="swift"&gt;var numberOfLives = 99
var livesLabel = &amp;quot;You have \(numberOfLives - 1) lives remaining.&amp;quot;
// -&amp;gt; &amp;quot;You have 98 lives remaining.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class="footnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;

&lt;li id="fn1"&gt;
&lt;p&gt;Variables and constants that are explicitly declared as optional can be &lt;code&gt;nil&lt;/code&gt;. More on that later.&amp;nbsp;&lt;a href="#fnref1" rev="footnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;
</content>
    <summary>In this first section, we cover variables, constants, type inference, casting and string interpolation.</summary>
  </entry>
</feed>
